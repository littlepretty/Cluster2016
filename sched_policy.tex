\section{Cerberus and Optimization Enhancement}
\label{Sec:Scheduler}

%=======XY======
The traditional batch scheduler on system without burst buffer only
takes job size (required number of nodes) and expected runtime into scheduling decision making. 
The most commonly used scheduling policy are First Come First Serve with EASY backfilling~\cite{tsafrir-tpds-2007}.
However, on burst buffer enabled systems, 
the available amount of burst buffer capacity becomes the new scheduling constraint. 
Thus, we propose Cerberus, 
the batch scheduler with burst buffer awareness for 3-phase modeled jobs. 

% \subsection{Cerberus for 3-Phase Jobs}
% Traditional batch scheduler usually looks at the field of $c_i$ and $rt_i$
% when making scheduling decision.
% One straightforward way to make decisions on non-burst-buffer HPC system is
% First Come First Serve, as long as available compute nodes can satisfy user job.
% Once the system is equipped with burst buffer, scheduler must consider a new constraint:
% the available amount of burst buffer capacity.
% Scheduling is divided into 3 phases to
% adopt to the 3-phase characteristic of jobs in burst buffer context.
% As shown in Figure~\ref{Fig:CerberusQueues},
% Cerberus schedules jobs in 3 distinct set/queue.
% The input queue $Q_I$ contains all the jobs that
% needs to load input data before they are able to execute.
% Once a job comes out of input queue, its data flows from external disk
% to burst buffer nodes, indicated by the red arrow.
% Compute nodes are not allocated to the application until
% data flows from burst buffer to memory on compute nodes.
% The run queue $Q_R$ contains all the jobs waiting to be run with loaded data.
% Before executing, input data must be transfered to memory on compute nodes,
% after which burst buffer used for stage-in can be released.
% When running application request checkpointing, its execution and data are
% pushed to its exclusive burst buffer nodes;
% when application resume from system fault, its checkpointing are
% loaded directly from burst buffer, instead of PFS, to compute nodes.
% The output queue $Q_O$ contains all the jobs that
% terminate execution but needs to write output data to external storage.
% As soon as output data is moved from memory to burst buffer nodes allocated for stage-out,
% compute nodes can be released;
% in other words, other applications ready to run can take up them now.
% At anytime, a job can only appear in one of the 3 sets, apparently.
% This fact motivates separated scheduling idiom to be used in different phases,
% or for different job queues.

%==================XY==============================
\subsection{Cerberus Overview}
As shown in Figure~\ref{Fig:CerberusQueues},
the input queue $Q_I$ contains all the jobs that
needs to pre-fetch data from external storage to burst buffer.
When the data flows from external disk
to burst buffer nodes, indicated by the red arrow, the job enters the run queue $Q_R$, 
waiting for compute nodes to be allocated.
Once the job gets the required number of compute nodes, it can start to run.
There might be frequent data exchange between burst buffer and compute nodes during the running phase. 
The job enters the output queue $Q_O$ after finishing computation, 
and waits for its output data being drained out to external storage. 

There could be multiple jobs waiting in each queue at the same time. 
Cerberus schedules the jobs in each queue separately, 
rather than being held in a particular queue and waiting for certain resources.
Cerberus can deploy different optimization algorithms for making scheduling decision
for jobs waiting in each queue.


% \subsection{Optimize Stage-in Phase}
% In the stage-in phase, only burst buffer demand is considered.
% Scheduling is made based on the value of $bb\_in$ of jobs in $Q_I$.
% If we care about data transfer throughput,
% we should transfer as much data as possible by doing the following optimization:
% \begin{align*}
%         & \max \sum_{i\in S} bb\_in_i \\
%         & s.t. \sum_{i\in S} bb\_in_i \leq BB_{available} \numberthis \label{Equ:MaxTransferData}
%         %\left\{
%                 %\begin{array}{l}
%                         %S \subseteq J_{Q_I} \\ [1em]
%                         %\sum_{i\in S} bb\_in_i \leq BB_{available}
%                 %\end{array} 
%         %\right.
% \end{align*}
% where $J_{Q_I}$ stands for all jobs in input queue at the time considering,
% $S\subseteq J_{Q_I}$ is the set of job selected by Cerberus,
% $bb\_in_i$ is the burst buffer demand of $job_i$,
% $BB_{available}$ is system's available amount of burst buffer.
% 
% Stage-out phase scheduling are made based on the value of $bb\_out$ of jobs in $Q_O$.
% Optimization formula for different purpose are almost the same as
% Equation~\ref{Equ:MaxTransferData},
% except that $bb\_in$ is replaced with $bb\_out$,
% $J_{Q_I}$ is replaced with $J_{Q_O}$, the job set of output queue.


%==============XY====================
\subsection{Scheduling in Stage-in Phase}

In the stage-in phase, jobs require only for burst buffer.
Cerberus schedule jobs in $Q_I$ based on their burst buffer demand $bb\_in$.
With the objective of maximizing resource utilization, 
Cerberus schedules jobs by the following optimization:
\begin{align*}
        & \max \sum_{i\in S} bb\_in_i \\
        & s.t. \sum_{i\in S} bb\_in_i \leq BB_{available} \numberthis \label{Equ:MaxTransferData}
        %\left\{
                %\begin{array}{l}
                        %S \subseteq J_{Q_I} \\ [1em]
                        %\sum_{i\in S} bb\_in_i \leq BB_{available}
                %\end{array} 
        %\right.
\end{align*}
where $J_{Q_I}$ stands for all jobs in input queue,
$S\subseteq J_{Q_I}$ is the set of job selected by Cerberus,
$bb\_in_i$ is the burst buffer demand of job $j_i$,
$BB_{available}$ is system's available amount of burst buffer.

Stage-out phase scheduling are made based on the value of $bb\_out$ of jobs in $Q_O$.
Optimization formula for stage-out phase are almost the same as
Equation~\ref{Equ:MaxTransferData},
except that $bb\_in$ is replaced with $bb\_out$,
$J_{Q_I}$ is replaced with $J_{Q_O}$, the job set of output queue.





% \subsection{Optimize Running Phase}
% Running jobs require not only compute nodes, but burst buffer to ensure performance and correctness.
% Scheduling are accordingly made based on the value of $c$ and $bb\_run$ of jobs in $Q_R$.
% To maximize multiple types of resource's utilization,
% we convert it to the knapsack problem by defining the value of the $job_i$ as
% \begin{equation}
%         v_i = \frac{c_i / CN}{rt_i} \times \frac{bb\_run_i / BB}{rt_i}
%         \label{Equ:DefValue}
% \end{equation}
% where $rt_i$ is the running time of $job_i$, the time it takes up the computing nodes.
% By defining \textit{value} as Equation~\ref{Equ:DefValue},
% we prefer these tasks that claims to take up node resources with short duration.
% Unfortunately, it is difficult to predict $rt_i$ before actually running the job.
% Of course we could use the \textit{expected running time} $ert_i$ specified by user.
% However, by examining the log traces from Argonne National Laboratory (ANL)\cite{JobTrace},
% we found that the variance between $rt_i$ and $ert_i$ is significantly different.
% For now we can just assume $ert_i$ represent $rt_i$ of $job_i$.
% In the future, we could adopt machine learning or data mining ideas
% to predict the running time of a job with demand vector.
% %Notice that then the value of a task is proportional to $c_i*bb_i$.
% The optimizing formula can thus be
% \begin{align*}
%         & \max \sum_{i \in S}\frac{c_i}{ert_i} * \frac{bb\_run_i}{ert_i} \\
%         & s.t. \left\{
%                 \begin{array}{l}
%                         %S \subseteq J_{Q_R} \\ [1em]
%                         \sum_{i \in S} c_i \leq CN_{available} \\ [0.5em]\numberthis \label{Equ:MaxProduct} 
%                         \sum_{i \in S} bb\_run_i \leq BB_{available}
%                 \end{array} 
%         \right.
% \end{align*}
% where $J_{Q_R}$ is the set of jobs in running queue,
% $S\subseteq J_{Q_R}$ stands for jobs selected by scheduler,
% $CN_{available}$ and $BB_{available}$ represent the amount of system's available resources
% (compute nodes and burst buffer nodes) at current moment.



\subsection{Scheduling in Running Phase}
Running jobs require not only compute nodes, but burst buffer to ensure performance and correctness.
Cerberus schedules jobs in $Q_R$ based on the $c$ and $bb\_run$.
To maximize the utilization of compute nodes and burst buffer, 
the scheduling objective is modeled as a knapsack problem by defining the \textbf{value} of the $j_i$ as
\begin{equation}
        v_i = \frac{c_i / CN}{ert_i} \times \frac{bb\_run_i / BB}{ert_i}
        \label{Equ:DefValue}
\end{equation}
where $ert_i$ is the expected running time of $j_i$.
By defining \textit{value} as Equation~\ref{Equ:DefValue},
we prefer these tasks that claims to take up node resources with short duration.
The optimizing formula can thus be
\begin{align*}
        & \max \sum_{i \in S}\frac{c_i}{ert_i} * \frac{bb\_run_i}{ert_i} \\
        & s.t. \left\{
                \begin{array}{l}
                        %S \subseteq J_{Q_R} \\ [1em]
                        \sum_{i \in S} c_i \leq CN_{available} \\ [0.5em]\numberthis \label{Equ:MaxProduct} 
                        \sum_{i \in S} bb\_run_i \leq BB_{available}
                \end{array} 
        \right.
\end{align*}
where $J_{Q_R}$ is the set of jobs in running queue,
$S\subseteq J_{Q_R}$ stands for jobs selected by scheduler,
$CN_{available}$ and $BB_{available}$ represent the amount of system's available resources
(compute nodes and burst buffer nodes) at current moment.



\subsection{Solving the Optimization Problems}
% It is trivial to show that optimization problem~\ref{Equ:MaxTransferData}
% is equivalent to 0-1 knapsack problem.
% Problem~\ref{Equ:MaxProduct} can be informally treat as 2-dimension 0-1 knapsack problem.
% We expect all of them are NP-hard problems.
% We can solve them with dynamic programming in pseudo polynomial time.
% Applying memorization could also help accelerate the solving process.
% However, we are not interested in the optimal result of
% problem~\ref{Equ:MaxTransferData} and problem~\ref{Equ:MaxProduct}
% but in a combination of jobs that yields the optimal solution,
% which, fortunately, can also be tracked back down
% using the memorizations kept in dynamic programming.

% %The solution to Problem~\ref{Equ:MaxTransferData},
% %Problem~\ref{Equ:MaxTaskNumber} and Problem~\ref{Equ:MaxProduct} are similar.
% First, for Problem~\ref{Equ:MaxTransferData}, the recursive relationship is
% given by Recursion~\ref{Equ:MaxTransferDataRecursion}.
% In~\ref{Equ:MaxTransferDataRecursion}, the memo we keeps during solving is
% the optimal solution for 
% $jobs=(job_1, job_2, \ldots, job_i)$ with $w$ GB of available burst buffer.
% For Problem~\ref{Equ:MaxProduct}, we keep the memo of the optimal solution 
% for $jobs=(job_1, job_2, \ldots, job_i)$
% with $c$ computing nodes and $w$ GB of burst buffer being available.

% Scheduler can obtain an optimal combination of jobs by tracking along the memo.
% Take the problem~\ref{Equ:MaxProduct} problem for example.
% We start from $dp(n, CN, BB)$.
% If $c_n \leq CN$ and $bb\_in_n \leq BB$, $job_n$ should be scheduled if
% $dp(i-1, c, w) \leq dp(i-1, c - c_i, w - bb\_in_i) + c_i bb\_in_i$ and
% recurse with $dp(n - 1, CN - c_i, BB - bb\_in_i)$;
% otherwise, $job_n$ should be skipped and we recurse the process on $dp(n-1, CN, BB)$.
% The time complexity of solving Recursion~\ref{Equ:MaxTransferDataRecursion} is $O(n\times BB)$.
% The time complexity of solving Recursion~\ref{Equ:MaxProductRecursion}
% is $O(n\times CN\times BB)$.

% Notice that $CN$ and $BB$ may be very large integers,
% making the pseudo-polynomial algorithm unsuitable
% to be used online by scheduler.
% In practice, we could reduce the time complexity by allocating resource
% in a coarser granularity.
% For example, jobs usually asks for compute node in the unit of $cn\_unit = 512$ nodes;
% demands for burst buffer nodes on checkpointing and output are
% usually in the unit of $bb\_unit = 1$ TB.
% We can divide both $CN$ and $c_i$ by $cn\_unit$;
% divide both $BB$ and $bb\_run, bb\_out$ by $bb\_unit$.
% It is also possible to reduce the value of $n$, the number of jobs in the queue.
% For example, we can consider only $\frac{1}{\alpha}n$ jobs in the queue.
% This will give us only the partial optimal solution
% in exchange of less computation complexity.

It is trivial to show that optimization problem~\ref{Equ:MaxTransferData}
is equivalent to 0-1 knapsack problem.
Problem~\ref{Equ:MaxProduct} can be informally treat as 2-dimension 0-1 knapsack problem.
We expect all of them to be NP-hard problems.
Dynamic programming is adopted to solve them in pseudo polynomial time.
Applying memorization could also help accelerate the solving process.
In addition, we are not interested in the optimal result of
problem~\ref{Equ:MaxTransferData} and problem~\ref{Equ:MaxProduct}
but in a combination of jobs $\mathcal{J}$ that yields the optimal solution,
which, fortunately, can also be tracked back down
using the memorizations kept during dynamic programming.
How to fill in memo and track back optimal $\mathcal{J}$ are shown in Algorithm~\ref{Alg:MaxBB}
and Algorithm~\ref{Alg:MaxCPU} for Problem~\ref{Equ:MaxTransferData}
and Problem~\ref{Equ:MaxProduct} respectively.
The time complexity of Algorithm~\ref{Alg:MaxBB} is $O(n\times BB)$.
The time complexity of solving Algorithm~\ref{Alg:MaxCPU} is $O(n\times CN\times BB)$.
%For Problem~\ref{Equ:MaxTransferData}, the recursive relationship is
%given by Recursion~\ref{Equ:MaxTransferDataRecursion}.
%For Problem~\ref{Equ:MaxProduct}, the recursive relationship is
%given by Recursion~\ref{Equ:MaxProductRecursion}.
%The time complexity of solving Recursion~\ref{Equ:MaxTransferDataRecursion} is $O(n\times BB)$.
%The time complexity of solving Recursion~\ref{Equ:MaxProductRecursion}
%is $O(n\times CN\times BB)$.

%\begin{strip}
        %\begin{align}
                %dp(i, w) = & 
                %\left\{
                        %\begin{array}{l}
                                %0, \text{ if $i=0$ } \\ [0.4em]
                                %dp(i-1, w), \text{ if $bb\_in_i > w$} \\ [0.4em]
                                %\max \{ dp(i-1, w), dp(i-1, w-bb\_in_i) + bb\_in_i \}, \text{ if $bb\_in_i \leq w$}
                        %\end{array} 
                %\right.
                %\label{Equ:MaxTransferDataRecursion} 
        %\end{align}
%\end{strip}

%\begin{strip}
        %\begin{align}
                %dp(i, c, w) = &
                %\left\{
                        %\begin{array}{l}
                                %0, \text{ if $i=0$ } \\ [0.4em]
                                %dp(i-1, c, w), \text{ if $c_i > c$ or $bb\_run_i > w$} \\ [0.4em]
                                %\max \{ dp(i-1, c, w), dp(i-1, c - c_i, w - bb\_run_i) + v_i \}, \text{ if $c_i \leq c$ and $bb\_run_i \leq w$}
                        %\end{array} 
                %\right.
                %\label{Equ:MaxProductRecursion}
        %\end{align}
%\end{strip}


\algrenewcommand{\algorithmiccomment}[1]{\hskip1em$/*$ #1 $*/$}

\begin{algorithm}[t]
\caption{Maximize Data Transfer of Jobs in $Q_I$ or $Q_O$}
\label{Alg:MaxBB}
\begin{algorithmic}[1]
        \State $\boldsymbol{bb} \gets $ burst buffer demands of $J_Q = (j_1, j_2,\ldots, j_N)$
        \State $\boldsymbol{dp} \gets \boldsymbol{0}_{(N+1) \times (BB+1)}$
        \State $\mathcal{J} \gets \emptyset$\Comment{scheduling result}
        \\
        \Function{FillInMemo}{}
                \For{$i \gets 1, N$}
                        \For{$w \gets 1, BB$}
                                \If{$w \geq bb_i$}
                                        \State $dp_1 = dp(i-1, w-bb_i)+bb_i$
                                        \State $dp_2 = dp(i-1, w)$
                                        \State $dp(i, w) \gets \max\{dp_1, dp_2\}$
                                \Else
                                        \State $dp(i,w) \gets dp(i-1,w)$
                                \EndIf
                        \EndFor
                \EndFor
                \State \Call{TrackBackJobs}{$N, BB$}
        \EndFunction
        \\
        \Function{TrackBackJobs}{$i, w$}
                \If{$i > 0$}
                        \If{$w \geq bb_i$}
                                \State $dp_1 = dp(i-1, w-bb_i)+bb_i$
                                \State $dp_2 = dp(i-1, w)$
                                \If{$dp_1 \geq dp_2$}
                                        \State $\mathcal{J} = \mathcal{J} \cup j_i$
                                        \State \Call{TrackBackJobs}{$i-1, w-bb_i$}
                                \Else
                                        \State \Call{TrackBackJobs}{$i-1, w$}
                                \EndIf
                        \Else
                                \State \Call{TrackBackJobs}{$i-1, w$}
                        \EndIf
                \EndIf
        \EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[t]
\caption{Maximize Profit of Jobs in $Q_R$}
\label{Alg:MaxCPU}
\begin{algorithmic}[1]
        \State $\boldsymbol{bb} \gets $ burst buffer demands of $J_Q = (j_1, j_2,\ldots, j_N)$
        \State $\boldsymbol{cpu} \gets $ compute nodes demands of $j \in J_Q$
        \State $\boldsymbol{dp} \gets \boldsymbol{0}_{(N+1) \times (CN) \times (BB+1)}$
        \State $\boldsymbol{v} \gets$ values of $j \in J_Q$
        \State $\mathcal{J} \gets \emptyset$\Comment{scheduling result} 
        \\
        \Function{FillInMemo}{}
                \For{$i \gets 1, N$}
                        \For{$c \gets 1, CN$} 
                                \For{$w \gets 1, BB$}
                                        \If{$c \geq cpu_i$ and $w \geq bb_i$}
                                                \State $dp_1 = dp(i-1, c-cpu_i, w-bb_i)+v_i$
                                                \State $dp_2 = dp(i-1, c, w)$
                                                \State $dp(i, c, w) \gets \max\{dp_1, dp_2\}$
                                        \Else
                                                \State $dp(i,c,w) \gets dp(i-1,c,w)$
                                        \EndIf
                                \EndFor
                        \EndFor
                \EndFor
                \State \Call{TrackBackJobs}{$N, CN, BB$}
        \EndFunction
        \\
        \Function{TrackBackJobs}{$i, c, w$}
                \If{$i > 0$}
                        \If{$c \geq cpu_i$ and $w \geq bb_i$}
                                \State $dp_1 = dp(i-1, c-cpu_i, w-bb_i)+v_i$
                                \State $dp_2 = dp(i-1, c, w)$
                                \If{$dp_1 \geq dp_2$}
                                        \State $\mathcal{J} = \mathcal{J} \cup j_i$
                                        \State \Call{TrackBackJobs}{$i-1, c-cpu_i, w-bb_i$}
                                \Else
                                        \State \Call{TrackBackJobs}{$i-1, c, w$}
                                \EndIf
                        \Else
                                \State \Call{TrackBackJobs}{$i-1, c, w$}
                        \EndIf
                \EndIf
        \EndFunction
\end{algorithmic}
\end{algorithm}

